{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome_to_mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project_layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"bam/","text":"BAM \u00b6","title":"BAM"},{"location":"bam/#bam","text":"","title":"BAM"},{"location":"commands/","text":"Commands \u00b6","title":"Commands"},{"location":"commands/#commands","text":"","title":"Commands"},{"location":"fa-gc/","text":"fa-gc \u00b6 Use fa-gc to calculate the GC content surrounding a given genomic position. The window sizes correspond to the distance upstream and downstream used to calculate GC content for. For example: 50 \u2013> \u201c100bp\u201d window, but a 101bp width is examined. Example output: > sc fa-gc --pos pos.tsv hg19.fa.gz 50 3200 500000 chrom pos gc_100 gc_6400 gc_1000000 chr1 50000 0.3663 0.373535 0.430292 chr1 50020 0.3663 0.373535 0.430288 chr1 50050 0.3564 0.373067 0.430283 Notes GC content calculations omit N bases. Output is sorted by chromosome, position.","title":"fa-gc"},{"location":"fa-gc/#fa-gc","text":"Use fa-gc to calculate the GC content surrounding a given genomic position. The window sizes correspond to the distance upstream and downstream used to calculate GC content for. For example: 50 \u2013> \u201c100bp\u201d window, but a 101bp width is examined. Example output: > sc fa-gc --pos pos.tsv hg19.fa.gz 50 3200 500000 chrom pos gc_100 gc_6400 gc_1000000 chr1 50000 0.3663 0.373535 0.430292 chr1 50020 0.3663 0.373535 0.430288 chr1 50050 0.3564 0.373067 0.430283 Notes GC content calculations omit N bases. Output is sorted by chromosome, position.","title":"fa-gc"},{"location":"fasta/","text":"FASTA \u00b6","title":"FASTA"},{"location":"fasta/#fasta","text":"","title":"FASTA"},{"location":"fastq/","text":"FASTQ \u00b6","title":"FASTQ"},{"location":"fastq/#fastq","text":"","title":"FASTQ"},{"location":"fq-count/","text":"fq-count \u00b6 Count the number of reads in a FASTQ and calculate additional metrics. Counts lines in a FASTQ Usage: fq-count [options] [fastq ...] Arguments: [fastq ...] Input FASTQ Options: -t, --header Output the header -b, --basename Add basename column -a, --absolute Add column for absolute path -h, --help Show this help Example \u00b6 sc fq-count --header -b *.fq reads gc_content gc_bases n_bases bases basename 8 0.53125 17 0 32 dup.fq 8 0.53125 17 0 32 dup.fq.gz 1 0.35 21 0 60 illumina_1.fq 1 0.35 21 0 60 illumina_2.fq 1 1 101 0 101 illumina_2000_2500.fq 6 0.35 126 0 360 illumina_3.fq 1 1 101 0 101 illumina_3000_4000.fq 1 0.35 21 0 60 illumina_4.fq 1 0.35 21 0 60 illumina_6.fq 1 0.35 21 0 60 illumina_7.fq 2 0.333333 14 0 42 illumina_8.fq 1 0.35 21 0 60 illumina_hiseq_x.fq 4 0.5 8 0 16 nodup.fq 9 0 0 0 9 novaseq.fq 2 0.430556 62 0 144 sra.fq","title":"fq-count"},{"location":"fq-count/#fq-count","text":"Count the number of reads in a FASTQ and calculate additional metrics. Counts lines in a FASTQ Usage: fq-count [options] [fastq ...] Arguments: [fastq ...] Input FASTQ Options: -t, --header Output the header -b, --basename Add basename column -a, --absolute Add column for absolute path -h, --help Show this help","title":"fq-count"},{"location":"fq-count/#example","text":"sc fq-count --header -b *.fq reads gc_content gc_bases n_bases bases basename 8 0.53125 17 0 32 dup.fq 8 0.53125 17 0 32 dup.fq.gz 1 0.35 21 0 60 illumina_1.fq 1 0.35 21 0 60 illumina_2.fq 1 1 101 0 101 illumina_2000_2500.fq 6 0.35 126 0 360 illumina_3.fq 1 1 101 0 101 illumina_3000_4000.fq 1 0.35 21 0 60 illumina_4.fq 1 0.35 21 0 60 illumina_6.fq 1 0.35 21 0 60 illumina_7.fq 2 0.333333 14 0 42 illumina_8.fq 1 0.35 21 0 60 illumina_hiseq_x.fq 4 0.5 8 0 16 nodup.fq 9 0 0 0 9 novaseq.fq 2 0.430556 62 0 144 sra.fq","title":"Example"},{"location":"fq-dedup/","text":"fq-dedup \u00b6 The fq-dedup command de-duplicates a FASTQ by read ID (e.g. @@D00446:1:140101_HWI-D00446_0001_C8HN4ANXX:8:2210:1238:2018 ). Ideally, you should never see this happen, bu true I have observed it when a power outage occurred during a sequencing runs. The command uses a Bloom filter to identify duplicates, and has to read through the file twice, and output the original FASTQ. sc fq-dedup myfastq.fq.gz 2> dup.err | gzip > dedupped.fq.gz fq-dedup can read both .fq.gz and .fq files. It sends the deduplicated FASTQ to stdout. Output Once complete, the following is sent to stderr: total_reads: 2500000 duplicates 1086043 false-positive: 0 false-positive-rate: 0.0 The false-positive values are for diagnostics only based on reads initially labeled as duplicates by the bloom filter that were later found not to be true duplicates. Benchmark 2.5M Reads; 1M+ duplicates; 2015 MacBook Pro 0m58.738s","title":"fq-dedup"},{"location":"fq-dedup/#fq-dedup","text":"The fq-dedup command de-duplicates a FASTQ by read ID (e.g. @@D00446:1:140101_HWI-D00446_0001_C8HN4ANXX:8:2210:1238:2018 ). Ideally, you should never see this happen, bu true I have observed it when a power outage occurred during a sequencing runs. The command uses a Bloom filter to identify duplicates, and has to read through the file twice, and output the original FASTQ. sc fq-dedup myfastq.fq.gz 2> dup.err | gzip > dedupped.fq.gz fq-dedup can read both .fq.gz and .fq files. It sends the deduplicated FASTQ to stdout. Output Once complete, the following is sent to stderr: total_reads: 2500000 duplicates 1086043 false-positive: 0 false-positive-rate: 0.0 The false-positive values are for diagnostics only based on reads initially labeled as duplicates by the bloom filter that were later found not to be true duplicates. Benchmark 2.5M Reads; 1M+ duplicates; 2015 MacBook Pro 0m58.738s","title":"fq-dedup"},{"location":"fq-meta/","text":"fq-meta \u00b6 Summarize FASTQ files, outputting the following: A best guess as to the type of sequencer based on instrument and flowcell information A best guess for the quality score format The barcode/index used to multiplex the sample which can be useful for identifying samples The machine, run, and other metadata about the FASTQ Information derived from the filename The file location fq-meta is useful for taking an inventory of sequencing data, and is particularly helpful if you are inheriting a poorly organized sequencing project. Data is output in a tab-delimited format so that this tool can be used to assemble a database of FASTQs and their associated information. You can do so like this: sc fq-meta --header > my_fq_database.txt # Use this to output just the variable names sc fq-meta *.fq.gz >> my_fq_database.txt The resulting dataset can be combined with other metadata and filtered to select samples for processing in a pipeline. You can also parallelize the operation with GNU-parallel . sc fq-meta --header > my_fq_database.txt # Use this to output just the variable names parallel -j 8 sc fq-meta ::: find . -name '*.fq.gz' >> my_fq_database.txt Example output machine sequencer prob_sequencer flowcell flowcell_description run lane sequence_id index1 index2 qual_format qual_phred qual_multiple min_qual max_qual n_lines basename absolute_path D00446 HiSeq2000/2500 high:machine+flowcell C8HN4ANXX High Output (8-lane) v4 flow cell 1 8 GCTCGGTA Sanger;Illumina 1.8+ Phred+33 TRUE 14 14 1 illumina_2000_2500.fq \u2026 K00100 HiSeq3000/4000 high:machine+flowcell H300JBBXX (8-lane) v1 flow cell 33 6 GCCAAT Sanger;Illumina 1.8+ Phred+33 TRUE 14 14 1 illumina_3000_4000.fq \u2026 D00209 HiSeq2000/2500 high:machine+flowcell CACDKANXX High Output (8-lane) v4 flow cell 258 6 CGCAGTT Sanger;Illumina 1.8+ Phred+33 TRUE 0 37 1 illumina_6.fq \u2026 D00209 HiSeq2000/2500 high:machine+flowcell CACDKANXX High Output (8-lane) v4 flow cell 258 6 GAGCAAG Sanger;Illumina 1.8+ Phred+33 TRUE 0 37 1 illumina_7.fq \u2026 __Input____ fq-meta accepts both gzipped FASTQs ( .fq.gz , .fastq.gz ~ inferred from .gz extension) and raw text FASTQs.","title":"fq-meta"},{"location":"fq-meta/#fq-meta","text":"Summarize FASTQ files, outputting the following: A best guess as to the type of sequencer based on instrument and flowcell information A best guess for the quality score format The barcode/index used to multiplex the sample which can be useful for identifying samples The machine, run, and other metadata about the FASTQ Information derived from the filename The file location fq-meta is useful for taking an inventory of sequencing data, and is particularly helpful if you are inheriting a poorly organized sequencing project. Data is output in a tab-delimited format so that this tool can be used to assemble a database of FASTQs and their associated information. You can do so like this: sc fq-meta --header > my_fq_database.txt # Use this to output just the variable names sc fq-meta *.fq.gz >> my_fq_database.txt The resulting dataset can be combined with other metadata and filtered to select samples for processing in a pipeline. You can also parallelize the operation with GNU-parallel . sc fq-meta --header > my_fq_database.txt # Use this to output just the variable names parallel -j 8 sc fq-meta ::: find . -name '*.fq.gz' >> my_fq_database.txt Example output machine sequencer prob_sequencer flowcell flowcell_description run lane sequence_id index1 index2 qual_format qual_phred qual_multiple min_qual max_qual n_lines basename absolute_path D00446 HiSeq2000/2500 high:machine+flowcell C8HN4ANXX High Output (8-lane) v4 flow cell 1 8 GCTCGGTA Sanger;Illumina 1.8+ Phred+33 TRUE 14 14 1 illumina_2000_2500.fq \u2026 K00100 HiSeq3000/4000 high:machine+flowcell H300JBBXX (8-lane) v1 flow cell 33 6 GCCAAT Sanger;Illumina 1.8+ Phred+33 TRUE 14 14 1 illumina_3000_4000.fq \u2026 D00209 HiSeq2000/2500 high:machine+flowcell CACDKANXX High Output (8-lane) v4 flow cell 258 6 CGCAGTT Sanger;Illumina 1.8+ Phred+33 TRUE 0 37 1 illumina_6.fq \u2026 D00209 HiSeq2000/2500 high:machine+flowcell CACDKANXX High Output (8-lane) v4 flow cell 258 6 GAGCAAG Sanger;Illumina 1.8+ Phred+33 TRUE 0 37 1 illumina_7.fq \u2026 __Input____ fq-meta accepts both gzipped FASTQs ( .fq.gz , .fastq.gz ~ inferred from .gz extension) and raw text FASTQs.","title":"fq-meta"},{"location":"insert-size/","text":"Insert-Size \u00b6 insert-size \u00b6 Calculate the insert-size of a bam or a set of bams. Bams are estimated by evaluating up to the 99.5th percentile of read insert-sizes. This gives numbers that are very close to Picard but a lot faster. sc insert-size --header input.bam # One bam sc insert-size --header *.bam # Multiple bams Options --verbose Output information about progress. --dist Output the frequency distribution of insert sizes. Output median mean std_dev min percentile_99.5 max_all n_reads n_accept n_use sample 179 176.5 63.954 38 358 359 237 101 100 AB1 Calculate insert-size metrics on a set of bams. Benchmark Below is a comparison of seq-collection with picard: The results are also very very close:","title":"insert-size"},{"location":"insert-size/#insert-size","text":"","title":"Insert-Size"},{"location":"insert-size/#insert-size_1","text":"Calculate the insert-size of a bam or a set of bams. Bams are estimated by evaluating up to the 99.5th percentile of read insert-sizes. This gives numbers that are very close to Picard but a lot faster. sc insert-size --header input.bam # One bam sc insert-size --header *.bam # Multiple bams Options --verbose Output information about progress. --dist Output the frequency distribution of insert sizes. Output median mean std_dev min percentile_99.5 max_all n_reads n_accept n_use sample 179 176.5 63.954 38 358 359 237 101 100 AB1 Calculate insert-size metrics on a set of bams. Benchmark Below is a comparison of seq-collection with picard: The results are also very very close:","title":"insert-size"},{"location":"introduction/","text":"Introduction \u00b6","title":"Introduction"},{"location":"introduction/#introduction","text":"","title":"Introduction"},{"location":"iter/","text":"The iter command operates on BAM/CRAM and VCF/BCF files, and is used to generate genomic ranges that can be used to process genomic data in chunks. It works well with tools such as xargs or gnu-parallel . Example sc iter test.bam 100,000 # Iterate on bins of 100k base pairs sc iter test.bam 100000 # Also valid sc iter test.bam 1e6 # Also valid # Outputs > I:0-999999 > I:1000000-1999999 > I:2000000-2999999 > I:3000000-3999999 > I:4000000-4999999 This list of genomic ranges can be used to process a BAM or VCF in parallel: function process_chunk { # Code to process chunk vcf=$1 region=$2 # e.g. bcftools call -m --region echo bcftools call --region $region $vcf # ... } # Export the function to make it available to GNU parallel export -f process_chunk parallel --verbose process_chunk ::: test.bam ::: $(sc iter test.bam) You can also set the [width] option to 0 to generate a list of chromosomes. iter \u00b6","title":"iter"},{"location":"iter/#iter","text":"","title":"iter"},{"location":"json/","text":"JSON \u00b6 json (VCF to JSON conversion) \u00b6 Convert a VCF to JSON. This is most useful in the context of a web-service, where you can serve variant data for the purposes of visualization, browsing, etc. For an example of what this might look like, see the elegans variation variant browser . The json command can be used to parse ANN columns (effect annotations) by specifying --annotation . Additionally, FORMAT fields (GT, DP, etc) can be zipped with sample names. Usage: sc json [options] vcf region Arguments: vcf VCF to convert to JSON region Region Options: -i, --info=INFO comma-delimited INFO fields; Use 'ALL' for everything -f, --format=FORMAT comma-delimited FORMAT fields; Use 'ALL' for everything -s, --samples=SAMPLES Set Samples (default: ALL) -p, --pretty Prettify result -a, --array Output as a JSON array instead of ind. JSON lines -z, --zip Zip sample names with FORMAT fields (e.g. {'sample1': 25, 'sample2': 34}) -n, --annotation Parse ANN Fields --pass Only output variants where FILTER=PASS --debug Debug -h, --help Show this help Example sc json --format=GT --zip --pretty tests/data/test.vcf.gz Outputs: { \"CHROM\": \"I\", \"POS\": 41947, \"ID\": \".\", \"REF\": \"A\", \"ALT\": [ \"T\" ], \"QUAL\": 999.0, \"FILTER\": [ \"PASS\" ], \"FORMAT\": { \"GT\": { \"AB1\": [ 2, 2 ], \"...\": [ 0, 0 ] } } } You can also specify custom SGT and TGT output formats which transform GT fields from their typical output. GT - Outputs genotypes as [[0, 0], [0, 1], [1, 1], \u2026 SGT - Outputs genotypes as 0/0 , 0/1 , 1/1 , \u2026 TGT - Outputs genotypes as T/T , A/T , A/A , \u2026","title":"json"},{"location":"json/#json","text":"","title":"JSON"},{"location":"json/#json_vcf_to_json_conversion","text":"Convert a VCF to JSON. This is most useful in the context of a web-service, where you can serve variant data for the purposes of visualization, browsing, etc. For an example of what this might look like, see the elegans variation variant browser . The json command can be used to parse ANN columns (effect annotations) by specifying --annotation . Additionally, FORMAT fields (GT, DP, etc) can be zipped with sample names. Usage: sc json [options] vcf region Arguments: vcf VCF to convert to JSON region Region Options: -i, --info=INFO comma-delimited INFO fields; Use 'ALL' for everything -f, --format=FORMAT comma-delimited FORMAT fields; Use 'ALL' for everything -s, --samples=SAMPLES Set Samples (default: ALL) -p, --pretty Prettify result -a, --array Output as a JSON array instead of ind. JSON lines -z, --zip Zip sample names with FORMAT fields (e.g. {'sample1': 25, 'sample2': 34}) -n, --annotation Parse ANN Fields --pass Only output variants where FILTER=PASS --debug Debug -h, --help Show this help Example sc json --format=GT --zip --pretty tests/data/test.vcf.gz Outputs: { \"CHROM\": \"I\", \"POS\": 41947, \"ID\": \".\", \"REF\": \"A\", \"ALT\": [ \"T\" ], \"QUAL\": 999.0, \"FILTER\": [ \"PASS\" ], \"FORMAT\": { \"GT\": { \"AB1\": [ 2, 2 ], \"...\": [ 0, 0 ] } } } You can also specify custom SGT and TGT output formats which transform GT fields from their typical output. GT - Outputs genotypes as [[0, 0], [0, 1], [1, 1], \u2026 SGT - Outputs genotypes as 0/0 , 0/1 , 1/1 , \u2026 TGT - Outputs genotypes as T/T , A/T , A/A , \u2026","title":"json (VCF to JSON conversion)"},{"location":"multi/","text":"MULTI \u00b6","title":"MULTI"},{"location":"multi/#multi","text":"","title":"MULTI"},{"location":"rand/","text":"rand \u00b6 rand Generate random genomic positions and ranges Usage: rand [options] input Arguments: input Input FASTA, BAM, or VCF or BAM Options: -n, --sites=SITES Number of sites (default: 10) -b, --bed=BED BED (0-based) of regions to restrict to -d, --dist=DIST Output regions following a distribution ex: N(1,5) [see docs] (default: 0) -p, --pattern=PATTERN A regular expression to use for chromosomes to keep -1, --one Output 1-based coordinates -h, --help Show this help The rand command is useful for generating random sites and ranges. You can apply the rand command to fasta , bam , or vcf files. If applied to a fasta file, the rand command will output the sequences. Options \u00b6 --pattern \u00b6 Use --pattern to restrict chromosomes in output. For example, the human genome contains additional contigs for alternative haplotypes, or unplaced contigs (e.g. chrUn_gl000216 ). See this UCSC FAQ for more information. sc rand --pattern \"chr[0-9MXY]+$\" hg19.fasta # only outputs chr1-22,X,Y,M Examples \u00b6 Sample regions with a normal distribution of \\(N(\\mu=5,\\sigma=3)\\). sc rand --dist=5,3 hg19.fasta Sample regions with a uniform distribution of \\(U(min=2,max=10)) sc rand --dist=2-10 hg19.fasta chr4 43446646 43446653 ATCTTTTA chr2 146664347 146664354 aagattga chr14 29047935 29047937 tca ... Sample 0 vs. 1 based coordinates \u00b6 rand automatically outputs coordinates that correspond to the input format. So: fasta - 0-based bam - 0-based vcf - 1-based You can force fasta / bam output to be 1-based using the -1 flag. Options \u00b6 n , --sites b , --bed -1 - Output 1-based coordinates instead of 0-based coordinates","title":"rand"},{"location":"rand/#rand","text":"rand Generate random genomic positions and ranges Usage: rand [options] input Arguments: input Input FASTA, BAM, or VCF or BAM Options: -n, --sites=SITES Number of sites (default: 10) -b, --bed=BED BED (0-based) of regions to restrict to -d, --dist=DIST Output regions following a distribution ex: N(1,5) [see docs] (default: 0) -p, --pattern=PATTERN A regular expression to use for chromosomes to keep -1, --one Output 1-based coordinates -h, --help Show this help The rand command is useful for generating random sites and ranges. You can apply the rand command to fasta , bam , or vcf files. If applied to a fasta file, the rand command will output the sequences.","title":"rand"},{"location":"rand/#options","text":"","title":"Options"},{"location":"rand/#--pattern","text":"Use --pattern to restrict chromosomes in output. For example, the human genome contains additional contigs for alternative haplotypes, or unplaced contigs (e.g. chrUn_gl000216 ). See this UCSC FAQ for more information. sc rand --pattern \"chr[0-9MXY]+$\" hg19.fasta # only outputs chr1-22,X,Y,M","title":"--pattern"},{"location":"rand/#examples","text":"Sample regions with a normal distribution of \\(N(\\mu=5,\\sigma=3)\\). sc rand --dist=5,3 hg19.fasta Sample regions with a uniform distribution of \\(U(min=2,max=10)) sc rand --dist=2-10 hg19.fasta chr4 43446646 43446653 ATCTTTTA chr2 146664347 146664354 aagattga chr14 29047935 29047937 tca ... Sample","title":"Examples"},{"location":"rand/#0_vs_1_based_coordinates","text":"rand automatically outputs coordinates that correspond to the input format. So: fasta - 0-based bam - 0-based vcf - 1-based You can force fasta / bam output to be 1-based using the -1 flag.","title":"0 vs. 1 based coordinates"},{"location":"rand/#options_1","text":"n , --sites b , --bed -1 - Output 1-based coordinates instead of 0-based coordinates","title":"Options"},{"location":"read-count/","text":"Read-Count \u00b6","title":"read-count"},{"location":"read-count/#read-count","text":"","title":"Read-Count"},{"location":"sample/","text":"Sample \u00b6 Randomly sample sites from a VCF sample Randomly sample a VCF Usage: sample [options] vcf Arguments: vcf Variant file Options: --bed=BED A set of bed regions to restrict sampling to -t, --types=TYPES Variant types to sample (all,snps,mnps,indels (default: all) -n, --sites=SITES Number of sites to sample (default: 10) -h, --help Show this help The sample command selects random variants. The algorithm works as follows. Chromosomes are weighted by length and randomly selected by their weights. A position is randomly selected. 1kb upstream is searched for variants and returned. If not, the process is repeated until the desired number of sites is returned. A bloom filter is used to reduce the likelihood of duplicates. The key used is the chromosome + position of each variant which prevents sampling of additional alleles located at the same position in subsequent draws. Options \u00b6 --types \u00b6 Select only sites that are snps , mnps (Multi-nucleotide polymorphism), or indels .","title":"sample"},{"location":"sample/#sample","text":"Randomly sample sites from a VCF sample Randomly sample a VCF Usage: sample [options] vcf Arguments: vcf Variant file Options: --bed=BED A set of bed regions to restrict sampling to -t, --types=TYPES Variant types to sample (all,snps,mnps,indels (default: all) -n, --sites=SITES Number of sites to sample (default: 10) -h, --help Show this help The sample command selects random variants. The algorithm works as follows. Chromosomes are weighted by length and randomly selected by their weights. A position is randomly selected. 1kb upstream is searched for variants and returned. If not, the process is repeated until the desired number of sites is returned. A bloom filter is used to reduce the likelihood of duplicates. The key used is the chromosome + position of each variant which prevents sampling of additional alleles located at the same position in subsequent draws.","title":"Sample"},{"location":"sample/#options","text":"","title":"Options"},{"location":"sample/#--types","text":"Select only sites that are snps , mnps (Multi-nucleotide polymorphism), or indels .","title":"--types"},{"location":"vcf/","text":"VCF \u00b6","title":"VCF"},{"location":"vcf/#vcf","text":"","title":"VCF"}]}